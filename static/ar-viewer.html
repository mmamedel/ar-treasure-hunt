<!doctype html>
<html lang="pt-BR">
	<head>
		<meta charset="UTF-8" />
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
		/>
		<meta name="mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
		<title>Caça ao Tesouro</title>
		<script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@0.160.0/build/three.module.js",
					"three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
					"mindar-image-three": "https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-three.prod.js"
				}
			}
		</script>
		<style>
			body {
				margin: 0;
				padding: 0;
				overflow: hidden;
				width: 100vw;
				height: 100vh;
				position: fixed;
				font-family:
					-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,
					sans-serif;
			}

			#container {
				width: 100vw;
				height: 100vh;
				position: fixed;
				top: 0;
				left: 0;
				overflow: hidden;
			}

			#loading {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				color: white;
				z-index: 9999;
				transition: opacity 0.5s;
			}

			#loading.hidden {
				opacity: 0;
				pointer-events: none;
			}

			.spinner {
				width: 50px;
				height: 50px;
				border: 4px solid rgba(255, 255, 255, 0.3);
				border-top-color: white;
				border-radius: 50%;
				animation: spin 1s linear infinite;
				margin-bottom: 20px;
			}

			@keyframes spin {
				to {
					transform: rotate(360deg);
				}
			}

			#treasureInfo {
				position: absolute;
				top: 20px;
				left: 20px;
				right: 20px;
				background: rgba(0, 0, 0, 0.8);
				color: white;
				padding: 20px;
				border-radius: 12px;
				backdrop-filter: blur(10px);
				z-index: 1000;
			}

			#treasureInfo h2 {
				margin: 0 0 10px 0;
				font-size: 20px;
			}

			#treasureInfo p {
				margin: 5px 0;
				font-size: 14px;
				line-height: 1.4;
			}

			#errorMessage {
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				background: rgba(220, 38, 38, 0.95);
				color: white;
				padding: 30px;
				border-radius: 12px;
				text-align: center;
				z-index: 9999;
				max-width: 80%;
			}

			#errorMessage h2 {
				margin: 0 0 10px 0;
			}

			#errorMessage button {
				margin-top: 20px;
				background: white;
				color: #dc2626;
				border: none;
				padding: 12px 24px;
				border-radius: 8px;
				font-weight: 600;
				cursor: pointer;
			}
		</style>
	</head>
	<body>
		<div id="loading">
			<div class="spinner"></div>
		</div>

		<div id="treasureInfo" style="display: none">
			<h2 id="treasureName"></h2>
			<p id="treasureClue"></p>
		</div>

		<div id="container"></div>

		<script type="module">
			import * as THREE from 'three';
			import { MindARThree } from 'mindar-image-three';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

			let TREASURES_CONFIG = [];
			let gameSession = null;
			let currentTreasure = null;
			let markerVisible = false;
			let mindarThree = null;
			let anchor = null;
			let model = null;
			let animationConfig = null;

			// Load treasure configuration from JSON
			async function loadTreasures() {
				try {
					const response = await fetch('treasures.json');
					TREASURES_CONFIG = await response.json();
					console.log('Treasures loaded:', TREASURES_CONFIG.length);
				} catch (error) {
					console.error('Error loading treasures:', error);
					showError('Erro ao carregar configuração dos tesouros');
				}
			}

			// Parse scale, rotation, position strings to arrays
			function parseVector3(str) {
				return str.split(' ').map(parseFloat);
			}

			// Apply animation to model based on configuration
			function applyAnimation(model, config) {
				if (!config || !config.type) return;

				const speed = config.speed || 1;

				switch (config.type) {
					case 'rotation':
						// Rotation animation
						const axis = config.axis || 'y';
						const rotationSpeed = speed * 0.01; // Convert to radians per frame

						if (axis === 'x') {
							model.rotation.x += rotationSpeed;
						} else if (axis === 'y') {
							model.rotation.y += rotationSpeed;
						} else if (axis === 'z') {
							model.rotation.z += rotationSpeed;
						}
						break;

					case 'bobbing':
						// Up and down bobbing animation
						const bobbingSpeed = speed * 0.05;
						const bobbingAmount = config.amount || 0.1;
						model.position.y += Math.sin(Date.now() * bobbingSpeed * 0.001) * bobbingAmount * 0.01;
						break;

					case 'scale-pulse':
						// Scale pulsing animation
						const pulseSpeed = speed * 0.002;
						const pulseAmount = config.amount || 0.1;
						const scaleFactor = 1 + Math.sin(Date.now() * pulseSpeed) * pulseAmount;
						model.scale.setScalar(scaleFactor);
						break;

					case 'swing':
						// Swinging/pendulum animation
						const swingSpeed = speed * 0.002;
						const swingAmount = config.amount || 0.3;
						const swingAxis = config.axis || 'z';

						if (swingAxis === 'x') {
							model.rotation.x = Math.sin(Date.now() * swingSpeed) * swingAmount;
						} else if (swingAxis === 'y') {
							model.rotation.y = Math.sin(Date.now() * swingSpeed) * swingAmount;
						} else if (swingAxis === 'z') {
							model.rotation.z = Math.sin(Date.now() * swingSpeed) * swingAmount;
						}
						break;

					default:
						console.warn(`Unknown animation type: ${config.type}`);
				}
			}

			// Initialize Three.js AR scene
			async function initARScene(treasureConfig) {
				// Initialize MindAR
				mindarThree = new MindARThree({
					container: document.querySelector('#container'),
					imageTargetSrc: treasureConfig.imageTarget
				});

				const { renderer, scene, camera } = mindarThree;

				// Add lights
				const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
				scene.add(light);

				// Add ambient light for overall scene brightness
				const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
				scene.add(ambientLight);

				// Add directional light for better illumination
				const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
				directionalLight.position.set(1, 2, 1);
				scene.add(directionalLight);

				// Add point light to illuminate the model
				const pointLight = new THREE.PointLight(0xffffff, 1, 10);
				pointLight.position.set(0, 1, 0.5);
				scene.add(pointLight);

				// Create anchor for the target
				anchor = mindarThree.addAnchor(treasureConfig.targetIndex);

				// Setup Draco decoder for compressed models
				const dracoLoader = new DRACOLoader();
				dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');

				// Load GLTF model
				const loader = new GLTFLoader();
				loader.setDRACOLoader(dracoLoader);
				loader.load(
					`models/${treasureConfig.model.file}`,
					(gltf) => {
						model = gltf.scene;

						// Apply scale, rotation, position from config
						const scale = parseVector3(treasureConfig.model.scale);
						model.scale.set(scale[0], scale[1], scale[2]);

						const rotation = parseVector3(treasureConfig.model.rotation);
						model.rotation.set(
							THREE.MathUtils.degToRad(rotation[0]),
							THREE.MathUtils.degToRad(rotation[1]),
							THREE.MathUtils.degToRad(rotation[2])
						);

						const position = parseVector3(treasureConfig.model.position);
						model.position.set(position[0], position[1], position[2]);

						// Store animation config if present
						animationConfig = treasureConfig.animation || null;

						// Add model to anchor
						anchor.group.add(model);

						console.log('Model loaded successfully');
					},
					undefined,
					(error) => {
						console.error('Error loading model:', error);
						showError('Erro ao carregar modelo 3D');
					}
				);

				// Setup target found/lost events
				anchor.onTargetFound = () => {
					markerVisible = true;
					console.log('Target found!');
					enableClickToContinue();
				};

				anchor.onTargetLost = () => {
					markerVisible = false;
					console.log('Target lost!');
				};

				// Start AR
				await mindarThree.start();

				// Start render loop
				renderer.setAnimationLoop(() => {
					// Apply animation if configured and model is loaded
					if (model && animationConfig) {
						applyAnimation(model, animationConfig);
					}
					renderer.render(scene, camera);
				});

				console.log('AR scene initialized');
			}

			// Initialize
			async function init() {
				try {
					// Load treasures first
					await loadTreasures();

					// Load game session from localStorage
					const sessionData = localStorage.getItem('GameSession');
					if (!sessionData) {
						showError('Nenhum jogo ativo encontrado. Inicie um jogo primeiro!');
						return;
					}

					gameSession = JSON.parse(sessionData);

					// Check if game is finished
					if (gameSession.isFinished) {
						showError('O jogo já foi finalizado!');
						return;
					}

					// Get current treasure from session
					const treasureIndex = gameSession.currentTreasureIndex;
					currentTreasure = gameSession.treasures[treasureIndex];

					if (!currentTreasure) {
						showError('Tesouro não encontrado na sessão!');
						return;
					}

					// Find matching treasure config by ID (supports randomized order)
					const treasureConfig = TREASURES_CONFIG.find((t) => t.id === currentTreasure.id);

					if (!treasureConfig) {
						showError('Configuração do tesouro não encontrada!');
						return;
					}

					// Initialize AR scene with Three.js
					await initARScene(treasureConfig);

					// Hide loading screen
					setTimeout(() => {
						document.getElementById('loading').classList.add('hidden');
					}, 500);
				} catch (error) {
					console.error('Error initializing AR:', error);
					showError('Erro ao carregar o jogo: ' + error.message);
				}
			}

			function enableClickToContinue() {
				document.getElementById('treasureInfo').style.display = 'block';
				// Update UI to show treasure was found
				document.getElementById('treasureInfo').innerHTML = `
					<h2> Tesouro Encontrado!</h2>
					<p>Toque na tela para continuar</p>
				`;
				// Enable click anywhere to continue
				document.body.style.cursor = 'pointer';
				// Add click listener to entire document
				document.addEventListener('click', handleTreasureFound, { once: true });
			}

			function handleTreasureFound() {
				if (!gameSession || !currentTreasure) return;

				const now = Date.now();

				// Update current treasure
				currentTreasure.found = true;
				currentTreasure.end = now;

				// Update treasures array in session
				gameSession.treasures[gameSession.currentTreasureIndex] = currentTreasure;

				// Check if all treasures have been found
				const allTreasuresFound = gameSession.treasures.every((treasure) => treasure.found);
				if (allTreasuresFound) {
					gameSession.end = now;
					gameSession.isFinished = true;
					console.log('Game completed! All treasures found.');
				}

				// Always set session sync to false
				gameSession.sync = false;

				// Save to localStorage
				localStorage.setItem('GameSession', JSON.stringify(gameSession));

				console.log('Treasure marked as found, redirecting...');
				// Redirect back to app immediately
				window.location.href = '/';
			}

			function showError(message) {
				const errorDiv = document.createElement('div');
				errorDiv.id = 'errorMessage';
				errorDiv.innerHTML = `
					<h2> Erro</h2>
					<p>${message}</p>
					<button onclick="window.location.href='/'">Voltar ao Jogo</button>
				`;
				document.body.appendChild(errorDiv);
				document.getElementById('loading').classList.add('hidden');
			}

			// Start when page loads
			window.addEventListener('load', init);
		</script>
	</body>
</html>
